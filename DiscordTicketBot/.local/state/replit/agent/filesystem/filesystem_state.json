{"file_contents":{"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/SETUP_GUIDE.md":{"content":"# Quick Setup Guide\n\nYour Discord bot is **running and ready**! Follow these steps to set it up in your server.\n\n## Step 1: Invite the Bot to Your Server\n\n1. Go to [Discord Developer Portal](https://discord.com/developers/applications)\n2. Select your bot application\n3. Go to **OAuth2** â†’ **URL Generator**\n4. Select scopes: `bot` and `applications.commands`\n5. Select bot permissions:\n   - Manage Threads\n   - Send Messages\n   - Embed Links\n   - Attach Files\n   - Read Message History\n   - Add Reactions\n   - Manage Messages\n6. Copy the generated URL and open it in your browser\n7. Select your server and authorize the bot\n\n## Step 2: Configure Your Server\n\nRun these commands in your Discord server (you must be the server owner):\n\n### 1. Set up the ticket creation channel\n```\n.sendticket\n```\nThis creates the persistent ticket dropdown menu. Members will select a category here to create tickets.\n\n### 2. Set the archive channel\n```\n.setarchive #archive-channel\n```\nReplace `#archive-channel` with your archive channel mention. All ticket transcripts will be posted here.\n\n### 3. Set the leaderboard channel\n```\n.setleaderboard #leaderboard-channel\n```\nReplace `#leaderboard-channel` with your leaderboard channel mention. Weekly leaderboards will auto-post here every Sunday at 4 AM EST.\n\n### 4. Set ticket limit (optional)\n```\n.ticketlimit 10\n```\nThis limits open tickets to 10. Adjust the number as needed. Set to 0 for unlimited tickets.\n\n## Step 3: Add Staff to Leaderboard\n\nAdd your staff members to the leaderboard with their appropriate roles:\n\n```\n.lb add @username owner\n.lb add @username co-owner\n.lb add @username admin\n.lb add @username staff\n.lb add @username trial\n```\n\nValid roles: `owner`, `co-owner`, `admin`, `staff`, `trial`\n\n## Available Commands\n\n### Owner Only\n- `.sendticket` - Post ticket creation message\n- `.ticketlimit <number>` - Set max open tickets\n- `.setarchive #channel` - Set archive channel\n- `.setleaderboard #channel` - Set leaderboard channel\n\n### Admin/Mod Only\n- `.close <reason>` - Close ticket with reason\n- `.claim force` - Force claim a ticket\n- `.unclaim force` - Force unclaim a ticket\n- `.modify @user <stat> <value>` - Modify user stats\n  - Stats: `wclosed`, `whandled`, `closed`, `handled`\n- `.lb add @user <role>` - Add user to leaderboard\n- `.lb remove @user <role>` - Remove user from leaderboard\n\n### Staff Commands\n- `.claim` - Claim a ticket\n- `.unclaim` - Unclaim a ticket\n- `.fm` - Jump to first message\n- `.add @user` - Add user to thread\n- `.remove @user` - Remove user from thread\n- `.rename <name>` - Rename thread\n- `.profile edit <message>` - Set profile message\n- `.stats [@user]` - View stats (with profile image)\n- `.lb` - All-time leaderboard\n- `.lb w` - Weekly leaderboard\n- `.lb c` - All-time closes leaderboard\n- `.lb cw` - Weekly closes leaderboard\n\n## Features\n\nâœ… **Ticket System**\n- 5 categories: Middleman, Pilot, Verify, Giveaway, Other\n- Automatic ticket numbering\n- Ticket limits with \"tickets full\" notification\n- Private thread creation\n\nâœ… **Ticket Management**\n- Claim/unclaim with credit tracking\n- Close with confirmation and reason\n- Full transcripts with timestamps\n- Archive posting with embed\n- DM to ticket opener with transcript\n\nâœ… **Statistics**\n- All-time and weekly tracking\n- Handled and closed counts\n- Custom profile messages\n- 885x303px profile image with banner/avatar\n\nâœ… **Leaderboards**\n- Role-based hierarchy display\n- Custom emojis for each role\n- Only shows sections with members\n- Weekly auto-posting (Sunday 4 AM EST)\n- Automatic weekly reset\n\n## Automation\n\nThe bot automatically:\n- Resets weekly stats every **Sunday at 4 AM EST**\n- Posts leaderboards every **Sunday at 4 AM EST**\n- Tracks all ticket actions for statistics\n- Generates transcripts on ticket close\n- Sends DMs to ticket openers\n\n## Need Help?\n\n- Check `README.md` for detailed documentation\n- Check `IMPLEMENTATION.md` for technical details\n- All data is stored in `bot_data.db` (SQLite database)\n\n## Bot Status\n\nCurrent Status: **âœ… Running as \"kirei#2389\"**\n\nEnjoy your Discord ticket and stats bot! ðŸŽ‰\n","size_bytes":4094},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiohttp>=3.13.1\",\n    \"aiosqlite>=0.21.0\",\n    \"discord-py>=2.6.4\",\n    \"pillow>=12.0.0\",\n    \"python-dotenv>=1.1.1\",\n    \"pytz>=2025.2\",\n]\n","size_bytes":287},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/image_utils.py":{"content":"from PIL import Image, ImageDraw, ImageFont, ImageFilter\nimport aiohttp\nimport io\nfrom typing import Optional\n\nasync def create_stats_image(\n    user,\n    banner_url: Optional[str],\n    avatar_url: str,\n    username: str,\n    join_date: Optional[str],\n    badges: list = []\n) -> io.BytesIO:\n    width = 885\n    height = 303\n    \n    img = Image.new('RGB', (width, height), color=(0, 0, 0))\n    \n    if banner_url:\n        async with aiohttp.ClientSession() as session:\n            async with session.get(banner_url) as resp:\n                if resp.status == 200:\n                    banner_data = await resp.read()\n                    banner = Image.open(io.BytesIO(banner_data))\n                    \n                    aspect = banner.width / banner.height\n                    target_aspect = width / height\n                    \n                    if aspect > target_aspect:\n                        new_height = height\n                        new_width = int(aspect * new_height)\n                    else:\n                        new_width = width\n                        new_height = int(new_width / aspect)\n                    \n                    banner = banner.resize((new_width, new_height), Image.Resampling.LANCZOS)\n                    banner = banner.filter(ImageFilter.GaussianBlur(radius=10))\n                    \n                    x = (new_width - width) // 2\n                    y = (new_height - height) // 2\n                    banner = banner.crop((x, y, x + width, y + height))\n                    \n                    img.paste(banner, (0, 0))\n    else:\n        async with aiohttp.ClientSession() as session:\n            async with session.get(avatar_url) as resp:\n                if resp.status == 200:\n                    avatar_data = await resp.read()\n                    avatar_bg = Image.open(io.BytesIO(avatar_data))\n                    \n                    aspect = avatar_bg.width / avatar_bg.height\n                    target_aspect = width / height\n                    \n                    if aspect > target_aspect:\n                        new_height = height\n                        new_width = int(aspect * new_height)\n                    else:\n                        new_width = width\n                        new_height = int(new_width / aspect)\n                    \n                    avatar_bg = avatar_bg.resize((new_width, new_height), Image.Resampling.LANCZOS)\n                    avatar_bg = avatar_bg.filter(ImageFilter.GaussianBlur(radius=15))\n                    \n                    x = (new_width - width) // 2\n                    y = (new_height - height) // 2\n                    avatar_bg = avatar_bg.crop((x, y, x + width, y + height))\n                    \n                    img.paste(avatar_bg, (0, 0))\n    \n    async with aiohttp.ClientSession() as session:\n        async with session.get(avatar_url) as resp:\n            if resp.status == 200:\n                avatar_data = await resp.read()\n                avatar = Image.open(io.BytesIO(avatar_data))\n                avatar = avatar.resize((250, 250), Image.Resampling.LANCZOS)\n                \n                mask = Image.new('L', (250, 250), 0)\n                mask_draw = ImageDraw.Draw(mask)\n                mask_draw.ellipse((0, 0, 250, 250), fill=255)\n                \n                img.paste(avatar, (30, 26), mask)\n    \n    draw = ImageDraw.Draw(img)\n    \n    try:\n        font_large = ImageFont.truetype(\"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\", 60)\n        font_small = ImageFont.truetype(\"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf\", 18)\n    except IOError:\n        font_large = ImageFont.load_default()\n        font_small = ImageFont.load_default()\n    \n    username_bbox = draw.textbbox((0, 0), username, font=font_large)\n    username_width = username_bbox[2] - username_bbox[0]\n    \n    avatar_right = 280\n    left_margin = 25\n    \n    min_text_x_for_left = avatar_right + left_margin + (username_width / 2)\n    center_x = width / 2\n    \n    text_x = max(center_x, min_text_x_for_left)\n    \n    draw.text((int(text_x), 120), username, fill=(255, 255, 255), font=font_large, anchor=\"mt\")\n    \n    if join_date and join_date != 'N/A':\n        if '<t:' in join_date:\n            join_text = join_date.split(':')[1].split(':')[0]\n            try:\n                from datetime import datetime\n                timestamp = int(join_text)\n                dt = datetime.fromtimestamp(timestamp)\n                join_text = f\"{dt.strftime('%b %d, %Y')}\"\n            except (ValueError, IndexError):\n                join_text = \"N/A\"\n        else:\n            join_text = join_date\n        \n        text_bbox = draw.textbbox((0, 0), join_text, font=font_small)\n        text_width = text_bbox[2] - text_bbox[0]\n        text_height = text_bbox[3] - text_bbox[1]\n        \n        padding = 15\n        circle_x = width - text_width - padding * 2 - 20\n        circle_y = height - text_height - padding * 2 - 20\n        circle_width = text_width + padding * 2\n        circle_height = text_height + padding * 2\n        \n        draw.rounded_rectangle(\n            ((circle_x, circle_y), (circle_x + circle_width, circle_y + circle_height)),\n            radius=20,\n            fill=(40, 40, 40, 200)\n        )\n        \n        text_x = circle_x + padding\n        text_y = circle_y + padding\n        draw.text((text_x, text_y), join_text, fill=(255, 255, 255), font=font_small)\n    \n    output = io.BytesIO()\n    img.save(output, format='PNG')\n    output.seek(0)\n    return output\n","size_bytes":5511},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/README.md":{"content":"# Discord Ticket & Stats Bot\n\nA comprehensive Discord bot for managing tickets, tracking staff statistics, and displaying leaderboards.\n\n## Features\n\n### Ticket System\n- **Category Selection**: Create tickets via dropdown (Middleman, Pilot, Verify, Giveaway, Other)\n- **Automatic Numbering**: Sequential ticket numbers for organization\n- **Ticket Limits**: Set maximum open tickets with `.ticketlimit`\n- **Claim/Unclaim System**: Staff can claim tickets for credit tracking\n- **Close with Transcripts**: Archive tickets with full transcripts and DM to opener\n- **Archive Channel**: Automatic transcript posting with embed summaries\n\n### Staff Commands\n- `.sendticket` - Post persistent ticket creation message (owner only)\n- `.ticketlimit <number>` - Set maximum open tickets (owner only)\n- `.setarchive #channel` - Set archive channel for transcripts (owner only)\n- `.setleaderboard #channel` - Set channel for weekly leaderboard posts (owner only)\n- `.claim` / `.claim force` - Claim a ticket\n- `.unclaim` / `.unclaim force` - Unclaim a ticket\n- `.close <reason>` - Close ticket with reason and transcript\n- `.fm` - Jump to first message in thread/channel\n- `.add @user` - Add user to thread\n- `.remove @user` - Remove user from thread\n- `.rename <name>` - Rename thread\n- `.profile edit <message>` - Set custom profile message\n- `.stats [@user]` - View user statistics with profile image\n- `.lb` - View all-time leaderboard (handles)\n- `.lb w` - View weekly leaderboard (handles)\n- `.lb c` - View all-time closes leaderboard\n- `.lb cw` - View weekly closes leaderboard\n- `.lb add @user <role>` - Add user to leaderboard role\n- `.lb remove @user <role>` - Remove user from leaderboard role\n- `.modify @user <stat> <value>` - Modify user statistics\n  - Stats: `wclosed`, `whandled`, `closed`, `handled`\n\n### Leaderboard System\n- **Role Hierarchy**: owner, co-owner, admin, staff, trial\n- **Custom Formatting**: Beautiful embeds with custom emojis\n- **Weekly Reset**: Automatic Sunday 4 AM EST weekly stats reset\n- **Auto-posting**: Leaderboards posted every Sunday 4 AM EST\n\n### Stats Tracking\n- All-time handled/closed tickets\n- Weekly handled/closed tickets\n- Custom profile messages\n- Role assignment dates\n- Profile images with Discord banner/avatar\n\n## Setup\n\n1. **Install Dependencies**:\n   Dependencies are already installed via the Replit environment.\n\n2. **Set Discord Token**:\n   The bot token will be requested when you run the bot.\n\n3. **Configure Server**:\n   - Run `.sendticket` in your ticket channel (owner only)\n   - Run `.setarchive #channel` to set archive channel\n   - Run `.setleaderboard #channel` to set leaderboard channel\n   - Run `.ticketlimit <number>` to set ticket limits\n\n4. **Add Staff to Leaderboard**:\n   - Use `.lb add @user owner` to add users to roles\n   - Valid roles: owner, co-owner, admin, staff, trial\n\n## Permissions\n\n### Owner Only\n- `.sendticket`\n- `.ticketlimit`\n- `.setarchive`\n- `.setleaderboard`\n\n### Admin/Mod Only\n- `.close`\n- `.claim force` / `.unclaim force`\n- `.modify`\n- `.lb add` / `.lb remove`\n\n### Staff\n- `.claim` / `.unclaim`\n- `.fm`\n- `.add` / `.remove`\n- `.rename`\n- `.profile edit`\n- `.stats`\n- `.lb` commands (view only)\n\n## Database\n\nThe bot uses SQLite for persistent storage:\n- Ticket data and transcripts\n- User statistics (all-time and weekly)\n- Leaderboard role assignments\n- Server configuration\n\nWeekly stats automatically reset every Sunday at 4 AM EST.\n","size_bytes":3427},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/database.py":{"content":"import sqlite3\nimport aiosqlite\nfrom datetime import datetime\nfrom typing import Optional, List, Dict, Tuple\n\nclass Database:\n    def __init__(self, db_path: str = \"bot_data.db\"):\n        self.db_path = db_path\n    \n    async def init_db(self):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                CREATE TABLE IF NOT EXISTS tickets (\n                    ticket_number INTEGER PRIMARY KEY AUTOINCREMENT,\n                    channel_id INTEGER UNIQUE,\n                    category TEXT,\n                    opener_id INTEGER,\n                    handler_id INTEGER,\n                    closer_id INTEGER,\n                    created_at TEXT,\n                    closed_at TEXT,\n                    close_reason TEXT,\n                    status TEXT DEFAULT 'open'\n                )\n            ''')\n            \n            await db.execute('''\n                CREATE TABLE IF NOT EXISTS user_stats (\n                    user_id INTEGER PRIMARY KEY,\n                    all_time_handled INTEGER DEFAULT 0,\n                    all_time_closed INTEGER DEFAULT 0,\n                    weekly_handled INTEGER DEFAULT 0,\n                    weekly_closed INTEGER DEFAULT 0,\n                    profile_message TEXT,\n                    role_assignment_date TEXT\n                )\n            ''')\n            \n            await db.execute('''\n                CREATE TABLE IF NOT EXISTS leaderboard_roles (\n                    user_id INTEGER,\n                    role_name TEXT,\n                    PRIMARY KEY (user_id, role_name)\n                )\n            ''')\n            \n            await db.execute('''\n                CREATE TABLE IF NOT EXISTS server_config (\n                    guild_id INTEGER PRIMARY KEY,\n                    ticket_limit INTEGER DEFAULT 0,\n                    archive_channel_id INTEGER,\n                    ticket_message_id INTEGER,\n                    ticket_channel_id INTEGER,\n                    leaderboard_channel_id INTEGER,\n                    staff_role_ids TEXT,\n                    admin_role_ids TEXT,\n                    owner_role_ids TEXT,\n                    moderator_role_ids TEXT\n                )\n            ''')\n            \n            async with db.execute(\"PRAGMA table_info(server_config)\") as cursor:\n                columns = await cursor.fetchall()\n                column_names = [col[1] for col in columns]\n                if 'admin_role_ids' not in column_names:\n                    await db.execute('ALTER TABLE server_config ADD COLUMN admin_role_ids TEXT')\n                if 'owner_role_ids' not in column_names:\n                    await db.execute('ALTER TABLE server_config ADD COLUMN owner_role_ids TEXT')\n                if 'moderator_role_ids' not in column_names:\n                    await db.execute('ALTER TABLE server_config ADD COLUMN moderator_role_ids TEXT')\n            \n            await db.execute('''\n                CREATE TABLE IF NOT EXISTS weekly_reset (\n                    id INTEGER PRIMARY KEY,\n                    last_reset TEXT\n                )\n            ''')\n            \n            await db.commit()\n    \n    async def get_ticket_limit(self, guild_id: int) -> int:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT ticket_limit FROM server_config WHERE guild_id = ?',\n                (guild_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                return result[0] if result else 0\n    \n    async def set_ticket_limit(self, guild_id: int, limit: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO server_config (guild_id, ticket_limit) \n                VALUES (?, ?) \n                ON CONFLICT(guild_id) DO UPDATE SET ticket_limit = ?\n            ''', (guild_id, limit, limit))\n            await db.commit()\n    \n    async def get_open_ticket_count(self) -> int:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                \"SELECT COUNT(*) FROM tickets WHERE status = 'open'\"\n            ) as cursor:\n                result = await cursor.fetchone()\n                return result[0] if result else 0\n    \n    async def create_ticket(self, channel_id: int, category: str, opener_id: int) -> int:\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute('''\n                INSERT INTO tickets (channel_id, category, opener_id, created_at, status)\n                VALUES (?, ?, ?, ?, 'open')\n            ''', (channel_id, category, opener_id, datetime.utcnow().isoformat()))\n            await db.commit()\n            return cursor.lastrowid\n    \n    async def claim_ticket(self, channel_id: int, handler_id: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                UPDATE tickets SET handler_id = ? WHERE channel_id = ?\n            ''', (handler_id, channel_id))\n            await db.commit()\n            \n            await db.execute('''\n                INSERT INTO user_stats (user_id, all_time_handled, weekly_handled)\n                VALUES (?, 1, 1)\n                ON CONFLICT(user_id) DO UPDATE SET\n                    all_time_handled = all_time_handled + 1,\n                    weekly_handled = weekly_handled + 1\n            ''', (handler_id,))\n            await db.commit()\n    \n    async def unclaim_ticket(self, channel_id: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT handler_id FROM tickets WHERE channel_id = ?',\n                (channel_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                if result and result[0]:\n                    handler_id = result[0]\n                    await db.execute('''\n                        UPDATE user_stats SET\n                            all_time_handled = all_time_handled - 1,\n                            weekly_handled = weekly_handled - 1\n                        WHERE user_id = ?\n                    ''', (handler_id,))\n                    \n            await db.execute('''\n                UPDATE tickets SET handler_id = NULL WHERE channel_id = ?\n            ''', (channel_id,))\n            await db.commit()\n    \n    async def close_ticket(self, channel_id: int, closer_id: int, reason: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                UPDATE tickets SET \n                    closer_id = ?,\n                    close_reason = ?,\n                    closed_at = ?,\n                    status = 'closed'\n                WHERE channel_id = ?\n            ''', (closer_id, reason, datetime.utcnow().isoformat(), channel_id))\n            await db.commit()\n            \n            await db.execute('''\n                INSERT INTO user_stats (user_id, all_time_closed, weekly_closed)\n                VALUES (?, 1, 1)\n                ON CONFLICT(user_id) DO UPDATE SET\n                    all_time_closed = all_time_closed + 1,\n                    weekly_closed = weekly_closed + 1\n            ''', (closer_id,))\n            await db.commit()\n    \n    async def get_ticket_info(self, channel_id: int) -> Optional[Dict]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT * FROM tickets WHERE channel_id = ?',\n                (channel_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                if result:\n                    return {\n                        'ticket_number': result[0],\n                        'channel_id': result[1],\n                        'category': result[2],\n                        'opener_id': result[3],\n                        'handler_id': result[4],\n                        'closer_id': result[5],\n                        'created_at': result[6],\n                        'closed_at': result[7],\n                        'close_reason': result[8],\n                        'status': result[9]\n                    }\n                return None\n    \n    async def get_user_stats(self, user_id: int) -> Dict:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT * FROM user_stats WHERE user_id = ?',\n                (user_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                if result:\n                    return {\n                        'user_id': result[0],\n                        'all_time_handled': result[1],\n                        'all_time_closed': result[2],\n                        'weekly_handled': result[3],\n                        'weekly_closed': result[4],\n                        'profile_message': result[5],\n                        'role_assignment_date': result[6]\n                    }\n                return {\n                    'user_id': user_id,\n                    'all_time_handled': 0,\n                    'all_time_closed': 0,\n                    'weekly_handled': 0,\n                    'weekly_closed': 0,\n                    'profile_message': None,\n                    'role_assignment_date': None\n                }\n    \n    async def update_profile_message(self, user_id: int, message: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO user_stats (user_id, profile_message)\n                VALUES (?, ?)\n                ON CONFLICT(user_id) DO UPDATE SET profile_message = ?\n            ''', (user_id, message, message))\n            await db.commit()\n    \n    async def modify_stats(self, user_id: int, stat_type: str, value: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(f'''\n                INSERT INTO user_stats (user_id, {stat_type})\n                VALUES (?, ?)\n                ON CONFLICT(user_id) DO UPDATE SET {stat_type} = {stat_type} + ?\n            ''', (user_id, value, value))\n            await db.commit()\n    \n    async def add_leaderboard_role(self, user_id: int, role_name: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT OR IGNORE INTO leaderboard_roles (user_id, role_name)\n                VALUES (?, ?)\n            ''', (user_id, role_name))\n            await db.commit()\n    \n    async def remove_leaderboard_role(self, user_id: int, role_name: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                DELETE FROM leaderboard_roles WHERE user_id = ? AND role_name = ?\n            ''', (user_id, role_name))\n            await db.commit()\n    \n    async def get_user_leaderboard_role(self, user_id: int) -> Optional[str]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT role_name FROM leaderboard_roles WHERE user_id = ?',\n                (user_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                return result[0] if result else None\n    \n    async def get_leaderboard_data(self, stat_type: str = 'all_time') -> List[Tuple]:\n        if stat_type == 'all_time':\n            stat_col = 'all_time_handled + all_time_closed'\n        elif stat_type == 'weekly':\n            stat_col = 'weekly_handled + weekly_closed'\n        elif stat_type == 'all_time_closed':\n            stat_col = 'all_time_closed'\n        elif stat_type == 'weekly_closed':\n            stat_col = 'weekly_closed'\n        else:\n            stat_col = 'all_time_handled + all_time_closed'\n        \n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(f'''\n                SELECT user_id, all_time_handled, all_time_closed, \n                       weekly_handled, weekly_closed\n                FROM user_stats\n                WHERE {stat_col} > 0\n                ORDER BY {stat_col} DESC\n            ''') as cursor:\n                return await cursor.fetchall()\n    \n    async def reset_weekly_stats(self):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                UPDATE user_stats SET weekly_handled = 0, weekly_closed = 0\n            ''')\n            await db.execute('''\n                INSERT OR REPLACE INTO weekly_reset (id, last_reset)\n                VALUES (1, ?)\n            ''', (datetime.utcnow().isoformat(),))\n            await db.commit()\n    \n    async def set_archive_channel(self, guild_id: int, channel_id: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO server_config (guild_id, archive_channel_id)\n                VALUES (?, ?)\n                ON CONFLICT(guild_id) DO UPDATE SET archive_channel_id = ?\n            ''', (guild_id, channel_id, channel_id))\n            await db.commit()\n    \n    async def get_archive_channel(self, guild_id: int) -> Optional[int]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT archive_channel_id FROM server_config WHERE guild_id = ?',\n                (guild_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                return result[0] if result else None\n    \n    async def set_ticket_message(self, guild_id: int, message_id: int, channel_id: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO server_config (guild_id, ticket_message_id, ticket_channel_id)\n                VALUES (?, ?, ?)\n                ON CONFLICT(guild_id) DO UPDATE SET \n                    ticket_message_id = ?,\n                    ticket_channel_id = ?\n            ''', (guild_id, message_id, channel_id, message_id, channel_id))\n            await db.commit()\n    \n    async def set_leaderboard_channel(self, guild_id: int, channel_id: int):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO server_config (guild_id, leaderboard_channel_id)\n                VALUES (?, ?)\n                ON CONFLICT(guild_id) DO UPDATE SET leaderboard_channel_id = ?\n            ''', (guild_id, channel_id, channel_id))\n            await db.commit()\n    \n    async def get_leaderboard_channel(self, guild_id: int) -> Optional[int]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT leaderboard_channel_id FROM server_config WHERE guild_id = ?',\n                (guild_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                return result[0] if result else None\n    \n    async def execute_raw(self, query: str, params: tuple = ()):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(query, params)\n            await db.commit()\n    \n    async def set_staff_roles(self, guild_id: int, role_ids: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute('''\n                INSERT INTO server_config (guild_id, staff_role_ids)\n                VALUES (?, ?)\n                ON CONFLICT(guild_id) DO UPDATE SET staff_role_ids = ?\n            ''', (guild_id, role_ids, role_ids))\n            await db.commit()\n    \n    async def get_staff_roles(self, guild_id: int) -> List[int]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                'SELECT staff_role_ids FROM server_config WHERE guild_id = ?',\n                (guild_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                if result and result[0]:\n                    return [int(rid) for rid in result[0].split(',')]\n                return []\n    \n    async def set_role_type(self, guild_id: int, role_type: str, role_ids: str):\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(f'''\n                INSERT INTO server_config (guild_id, {role_type}_role_ids)\n                VALUES (?, ?)\n                ON CONFLICT(guild_id) DO UPDATE SET {role_type}_role_ids = ?\n            ''', (guild_id, role_ids, role_ids))\n            await db.commit()\n    \n    async def get_role_type(self, guild_id: int, role_type: str) -> List[int]:\n        async with aiosqlite.connect(self.db_path) as db:\n            async with db.execute(\n                f'SELECT {role_type}_role_ids FROM server_config WHERE guild_id = ?',\n                (guild_id,)\n            ) as cursor:\n                result = await cursor.fetchone()\n                if result and result[0]:\n                    return [int(rid) for rid in result[0].split(',')]\n                return []\n","size_bytes":16857},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/bot.py":{"content":"import discord\nfrom discord.ext import commands, tasks\nfrom discord.ui import View, Select, Button\nimport os\nfrom dotenv import load_dotenv\nfrom database import Database\nfrom datetime import datetime\nimport pytz\nimport io\nfrom image_utils import create_stats_image\n\nload_dotenv()\n\nintents = discord.Intents.default()\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n\nbot = commands.Bot(command_prefix='.', intents=intents)\ndb = Database()\n\nEMBED_COLOR = 0xf9e6f0\n\nROLE_EMOJIS = {\n    'owner': '<a:white_butterflies:1390909884928884886>',\n    'co-owner': '<:piano_smile:1396035361091752080>',\n    'head admin': '<:miffy_plush:1390909592543957063>',\n    'admin': '<:miffy_plush:1390909592543957063>',\n    'staff': '<a:cutebunny:1390853287347228914>',\n    'trial staff': '<a:pink_bubbles:1396386164637958294>'\n}\n\nROLE_ORDER = ['owner', 'co-owner', 'head admin', 'admin', 'staff', 'trial staff']\nTRACKED_ROLE_IDS = [1390953916082028635, 1396008058693615678, 1428758437646307470]\nPING_ROLE_ID = 1407881544202195004\n\nSTAFF_ROLE_HIERARCHY = {\n    1390590641846878330: 'Owner',\n    1396033952535285790: 'Co-Owner',\n    1428181145899630785: 'Head Admin',\n    1390954184530202624: 'Admin',\n    1390954010650873918: 'Mod',\n    1390953916082028635: 'Trial Mod',\n    1395998827147952249: 'Lead MM',\n    1390953447393722410: 'MM',\n    1396008058693615678: 'Trial MM',\n    1390953663694114878: 'Pilot',\n    1428758437646307470: 'Trial Pilot'\n}\n\nasync def has_staff_permission(member: discord.Member, guild_id: int) -> bool:\n    staff_roles = await db.get_staff_roles(guild_id)\n    if not staff_roles:\n        return False\n    return any(role.id in staff_roles for role in member.roles)\n\nclass TicketCategorySelect(Select):\n    def __init__(self):\n        options = [\n            discord.SelectOption(label=\"Middleman\", value=\"middleman\", emoji=\"<a:white_butterflies:1390909884928884886>\"),\n            discord.SelectOption(label=\"Pilot\", value=\"pilot\", emoji=\"<a:white_butterflies:1390909884928884886>\"),\n            discord.SelectOption(label=\"Verify\", value=\"verify\", emoji=\"<a:white_butterflies:1390909884928884886>\"),\n            discord.SelectOption(label=\"Giveaway\", value=\"giveaway\", emoji=\"<a:white_butterflies:1390909884928884886>\"),\n            discord.SelectOption(label=\"Other\", value=\"other\", emoji=\"<a:white_butterflies:1390909884928884886>\")\n        ]\n        super().__init__(placeholder=\"Select a ticket category...\", options=options, min_values=1, max_values=1, custom_id=\"ticket_category_select\")\n    \n    async def callback(self, interaction: discord.Interaction):\n        category = self.values[0]\n        \n        ticket_limit = await db.get_ticket_limit(interaction.guild.id)\n        open_tickets = await db.get_open_ticket_count()\n        \n        if ticket_limit > 0 and open_tickets >= ticket_limit:\n            await interaction.response.send_message(\n                \"TAIYO is currently at max tickets. Please try again later.\",\n                ephemeral=True\n            )\n            return\n        \n        ticket_number = await db.create_ticket(0, category, interaction.user.id)\n        \n        thread = await interaction.channel.create_thread(\n            name=f\"ticket-{ticket_number}\",\n            type=discord.ChannelType.private_thread,\n            auto_archive_duration=10080\n        )\n        \n        await db.execute_raw(\n            'UPDATE tickets SET channel_id = ? WHERE ticket_number = ?',\n            (thread.id, ticket_number)\n        )\n        \n        await thread.add_user(interaction.user)\n        \n        embed = discord.Embed(\n            title=category.title(),\n            description=f\"Opened by {interaction.user.mention}\",\n            color=EMBED_COLOR\n        )\n        await thread.send(f\"<@&{PING_ROLE_ID}>\", embed=embed)\n        \n        await interaction.response.send_message(\n            f\"Ticket created! {thread.mention}\",\n            ephemeral=True\n        )\n\nclass TicketView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n        self.add_item(TicketCategorySelect())\n\nclass ConfirmView(View):\n    def __init__(self, user_id: int):\n        super().__init__(timeout=60)\n        self.value = None\n        self.user_id = user_id\n    \n    @discord.ui.button(label=\"Confirm\", style=discord.ButtonStyle.green)\n    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user.id != self.user_id:\n            await interaction.response.send_message(\"This is not your confirmation!\", ephemeral=True)\n            return\n        self.value = True\n        self.stop()\n        await interaction.response.defer()\n    \n    @discord.ui.button(label=\"Cancel\", style=discord.ButtonStyle.red)\n    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user.id != self.user_id:\n            await interaction.response.send_message(\"This is not your confirmation!\", ephemeral=True)\n            return\n        self.value = False\n        self.stop()\n        await interaction.response.defer()\n\n@bot.event\nasync def on_ready():\n    await db.init_db()\n    bot.add_view(TicketView())\n    print(f'Bot is ready! Logged in as {bot.user}')\n    if not weekly_reset_task.is_running():\n        weekly_reset_task.start()\n    if not sunday_leaderboard.is_running():\n        sunday_leaderboard.start()\n\n@bot.command()\nasync def sendticket(ctx):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    embed = discord.Embed(\n        title=\"Create a Ticket\",\n        description=\"Select a category below to create a ticket.\",\n        color=EMBED_COLOR\n    )\n    \n    view = TicketView()\n    msg = await ctx.send(embed=embed, view=view)\n    await db.set_ticket_message(ctx.guild.id, msg.id, ctx.channel.id)\n    await ctx.message.delete()\n\n@bot.command()\nasync def ticketlimit(ctx, limit: int):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    await db.set_ticket_limit(ctx.guild.id, limit)\n    await ctx.send(f\"Ticket limit set to {limit}!\", delete_after=5)\n\n@bot.command()\nasync def setarchive(ctx, channel: discord.TextChannel):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    await db.set_archive_channel(ctx.guild.id, channel.id)\n    await ctx.send(f\"Archive channel set to {channel.mention}!\", delete_after=5)\n\n@bot.command()\nasync def setleaderboard(ctx, channel: discord.TextChannel):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    await db.set_leaderboard_channel(ctx.guild.id, channel.id)\n    await ctx.send(f\"Leaderboard channel set to {channel.mention}!\", delete_after=5)\n\n@bot.command()\nasync def setstaffroles(ctx, *roles: discord.Role):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    if not roles:\n        await ctx.send(\"Please provide at least one role!\", delete_after=5)\n        return\n    \n    role_ids = ','.join(str(role.id) for role in roles)\n    await db.set_staff_roles(ctx.guild.id, role_ids)\n    role_mentions = ' '.join(role.mention for role in roles)\n    await ctx.send(f\"Staff roles set to: {role_mentions}\", delete_after=5)\n\n@bot.command()\nasync def setroles(ctx, role_type: str, *roles: discord.Role):\n    if ctx.author.id != ctx.guild.owner_id:\n        await ctx.send(\"Only the server owner can use this command!\", delete_after=5)\n        return\n    \n    valid_types = ['admin', 'owner', 'moderator', 'staff']\n    if role_type.lower() not in valid_types:\n        await ctx.send(f\"Invalid role type! Valid types: {', '.join(valid_types)}\", delete_after=5)\n        return\n    \n    if not roles:\n        await ctx.send(\"Please provide at least one role!\", delete_after=5)\n        return\n    \n    role_ids = ','.join(str(role.id) for role in roles)\n    \n    if role_type.lower() == 'staff':\n        await db.set_staff_roles(ctx.guild.id, role_ids)\n    else:\n        await db.set_role_type(ctx.guild.id, role_type.lower(), role_ids)\n    \n    role_mentions = ' '.join(role.mention for role in roles)\n    await ctx.send(f\"{role_type.title()} roles set to: {role_mentions}\", delete_after=5)\n\n@bot.command()\nasync def claim(ctx, force: str = \"\"):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    ticket_info = await db.get_ticket_info(ctx.channel.id)\n    if not ticket_info:\n        return\n    \n    if force == \"force\":\n        if not any(role.name.lower() in ['admin', 'mod', 'moderator'] for role in ctx.author.roles):\n            return\n        \n        if ticket_info['handler_id']:\n            await db.unclaim_ticket(ctx.channel.id)\n    else:\n        if not await has_staff_permission(ctx.author, ctx.guild.id):\n            return\n    \n    await db.claim_ticket(ctx.channel.id, ctx.author.id)\n    \n    embed = discord.Embed(\n        description=f\"{ctx.author.mention} has claimed the ticket\",\n        color=EMBED_COLOR\n    )\n    \n    msg = await ctx.send(embed=embed, reference=ctx.message)\n    await ctx.message.delete()\n\n@bot.command()\nasync def unclaim(ctx, force: str = \"\"):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    ticket_info = await db.get_ticket_info(ctx.channel.id)\n    if not ticket_info:\n        return\n    \n    if force == \"force\":\n        if not any(role.name.lower() in ['admin', 'mod', 'moderator'] for role in ctx.author.roles):\n            return\n    else:\n        if not await has_staff_permission(ctx.author, ctx.guild.id):\n            return\n        if ticket_info['handler_id'] != ctx.author.id:\n            return\n    \n    await db.unclaim_ticket(ctx.channel.id)\n    await ctx.send(\"Ticket has been unclaimed!\")\n\n@bot.command()\nasync def close(ctx, *, reason: str = \"No reason provided\"):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    ticket_info = await db.get_ticket_info(ctx.channel.id)\n    if not ticket_info:\n        await ctx.send(\"This is not a valid ticket thread!\")\n        return\n    \n    handler = await bot.fetch_user(ticket_info['handler_id']) if ticket_info['handler_id'] else None\n    credit_text = handler.mention if handler else \"No one\"\n    \n    confirmation_embed = discord.Embed(\n        title=\"Ticket Confirmation\",\n        description=\"are you sure you want to close?\",\n        color=EMBED_COLOR\n    )\n    confirmation_embed.add_field(name=\"Credit given:\", value=credit_text, inline=False)\n    \n    view = ConfirmView(ctx.author.id)\n    msg = await ctx.send(embed=confirmation_embed, view=view)\n    \n    await view.wait()\n    \n    if not view.value:\n        await msg.edit(content=\"Ticket close cancelled.\", view=None, embed=None)\n        return\n    \n    await db.close_ticket(ctx.channel.id, ctx.author.id, reason)\n    \n    ticket_info = await db.get_ticket_info(ctx.channel.id)\n    if not ticket_info:\n        await msg.edit(content=\"Error: Could not retrieve ticket information.\", view=None)\n        return\n    \n    messages = []\n    async for message in ctx.channel.history(limit=None, oldest_first=True):\n        messages.append(message)\n    \n    html_content = f\"\"\"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Ticket #{ticket_info['ticket_number']}</title>\n    <style>\n        body {{ font-family: Arial, sans-serif; padding: 20px; background: #36393f; color: #dcddde; }}\n        .message {{ margin: 10px 0; padding: 10px; background: #40444b; border-radius: 5px; }}\n        .author {{ color: #7289da; font-weight: bold; }}\n        .timestamp {{ color: #72767d; font-size: 0.8em; }}\n    </style>\n</head>\n<body>\n    <h1>Ticket #{ticket_info['ticket_number']}</h1>\n\"\"\"\n    for msg in messages:\n        timestamp = msg.created_at.strftime(\"%Y-%m-%d %H:%M:%S\")\n        content = msg.content.replace('<', '&lt;').replace('>', '&gt;')\n        html_content += f'    <div class=\"message\"><span class=\"author\">{msg.author}</span> <span class=\"timestamp\">{timestamp}</span><br>{content}</div>\\n'\n    \n    html_content += \"</body>\\n</html>\"\n    created_at = datetime.fromisoformat(ticket_info['created_at'])\n    closed_at = datetime.fromisoformat(ticket_info['closed_at'])\n    \n    opener = await bot.fetch_user(ticket_info['opener_id'])\n    handler = await bot.fetch_user(ticket_info['handler_id']) if ticket_info['handler_id'] else None\n    closer = await bot.fetch_user(ticket_info['closer_id'])\n    \n    created_timestamp = int(created_at.timestamp())\n    closed_timestamp = int(closed_at.timestamp())\n    \n    archive_channel_id = await db.get_archive_channel(ctx.guild.id)\n    if archive_channel_id:\n        archive_channel = bot.get_channel(archive_channel_id)\n        if archive_channel:\n            embed_description = f\"\"\"Ticket #{ticket_info['ticket_number']}\nopened by       closed by         handled by\n{opener.mention}                   {closer.mention}                {handler.mention if handler else 'None'}\nopened at\n<t:{created_timestamp}:F>\nclosed at\n<t:{closed_timestamp}:F>\nreason\n{reason}\"\"\"\n            \n            transcript_embed = discord.Embed(\n                description=embed_description,\n                color=EMBED_COLOR\n            )\n            \n            file = discord.File(io.BytesIO(html_content.encode()), filename=f\"ticket #{ticket_info['ticket_number']}.html\")\n            \n            button_view = View()\n            button_view.add_item(Button(label=\"View Thread\", url=ctx.channel.jump_url))\n            \n            await archive_channel.send(embed=transcript_embed, file=file, view=button_view)\n    \n    try:\n        dm_description = f\"\"\"Ticket #{ticket_info['ticket_number']}\nopened by       <:whitedash:1390902298166820996>        closed by       <:whitedash:1390902298166820996>          handled by\n{opener.mention}                                      {closer.mention}                               {handler.mention if handler else 'None'}\nopened at\n<t:{created_timestamp}:F>\nclosed at\n<t:{closed_timestamp}:F>\nreason\n{reason}\"\"\"\n        \n        dm_embed = discord.Embed(\n            description=dm_description,\n            color=EMBED_COLOR\n        )\n        \n        dm_button_view = View()\n        dm_button_view.add_item(Button(label=\"View Thread\", url=ctx.channel.jump_url))\n        \n        dm_file = discord.File(io.BytesIO(html_content.encode()), filename=f\"ticket #{ticket_info['ticket_number']}.html\")\n        await opener.send(embed=dm_embed, file=dm_file, view=dm_button_view)\n    except:\n        pass\n    \n    close_embed = discord.Embed(\n        title=f\"ticket closed <a:Heart:1396388971818520576>\",\n        description=f\"this ticket was closed by {ctx.author.mention}\\n\\n**reason:**\\n{reason}\",\n        color=EMBED_COLOR\n    )\n    \n    await msg.edit(embed=close_embed, view=None)\n    await ctx.channel.edit(archived=True, locked=True)\n\n@bot.command()\nasync def fm(ctx):\n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    messages = []\n    async for message in ctx.channel.history(limit=1, oldest_first=True):\n        messages.append(message)\n    \n    if messages:\n        first_msg = messages[0]\n        embed = discord.Embed(\n            description=f\"First message sent in {ctx.channel.mention} - [here]({first_msg.jump_url})\",\n            color=EMBED_COLOR\n        )\n        await ctx.send(embed=embed)\n\n@bot.command()\nasync def add(ctx, member: discord.Member):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    await ctx.channel.add_user(member)\n    await ctx.send(f\"Added {member.mention} to the thread!\")\n\n@bot.command()\nasync def remove(ctx, member: discord.Member):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    await ctx.channel.remove_user(member)\n    await ctx.send(f\"Removed {member.mention} from the thread!\")\n\n@bot.command()\nasync def rename(ctx, *, name: str):\n    if not isinstance(ctx.channel, discord.Thread):\n        return\n    \n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    print(f\"[DEBUG] Rename command called by {ctx.author} to '{name}'\")\n    await ctx.channel.edit(name=name)\n\n@bot.command()\nasync def profile(ctx, action: str = \"\", *, message: str = \"\"):\n    if action == \"edit\":\n        if not await has_staff_permission(ctx.author, ctx.guild.id):\n            return\n        \n        if not message:\n            return\n        \n        await db.update_profile_message(ctx.author.id, message)\n        await ctx.send(\"Profile message updated!\")\n    else:\n        return\n\n@bot.command()\nasync def stats(ctx, member: discord.Member = None):\n    print(f\"[DEBUG] Stats command called by {ctx.author} for {member}\")\n    if member is None:\n        member = ctx.author\n    \n    stats = await db.get_user_stats(member.id)\n    \n    banner_url = None\n    if member.banner:\n        banner_url = member.banner.url\n    \n    avatar_url = member.display_avatar.url\n    \n    highest_role = None\n    for role_id in STAFF_ROLE_HIERARCHY.keys():\n        role = ctx.guild.get_role(role_id)\n        if role and role in member.roles:\n            highest_role = STAFF_ROLE_HIERARCHY[role_id]\n            break\n    \n    ping_role = ctx.guild.get_role(PING_ROLE_ID)\n    join_date = None\n    if ping_role and ping_role in member.roles:\n        role_assignment_date = stats.get('role_assignment_date')\n        if role_assignment_date and role_assignment_date != 'N/A':\n            try:\n                from datetime import datetime\n                dt = datetime.fromisoformat(role_assignment_date)\n                timestamp_int = int(dt.timestamp())\n                join_date = f\"<t:{timestamp_int}:D>\"\n            except:\n                join_date = role_assignment_date\n        else:\n            join_date = \"N/A\"\n    \n    image_data = await create_stats_image(member, banner_url, avatar_url, member.name, join_date)\n    \n    embed = discord.Embed(\n        title=f\"{member.name}\",\n        description=stats.get('profile_message', ''),\n        color=EMBED_COLOR\n    )\n    \n    rank_value = highest_role if highest_role else \"N/A\"\n    closed_total = stats['all_time_closed']\n    closed_7d = stats['weekly_closed']\n    handled_total = stats['all_time_handled']\n    handled_7d = stats['weekly_handled']\n    \n    embed.add_field(name=\"Rank\", value=rank_value, inline=True)\n    embed.add_field(name=\"Closed Total\", value=str(closed_total), inline=True)\n    embed.add_field(name=\"Closed 7d\", value=str(closed_7d), inline=True)\n    \n    embed.add_field(name=\"Join Date\", value=join_date if join_date else \"N/A\", inline=True)\n    embed.add_field(name=\"Handled Total\", value=str(handled_total), inline=True)\n    embed.add_field(name=\"Handled 7d\", value=str(handled_7d), inline=True)\n    \n    embed.set_image(url=\"attachment://stats.png\")\n    \n    file = discord.File(image_data, filename=\"stats.png\")\n    await ctx.send(embed=embed, file=file)\n\n@bot.command()\nasync def lb(ctx, subcommand: str = \"\", member: discord.Member = None, role: str = \"\"):\n    print(f\"[DEBUG] LB command called by {ctx.author} with subcommand '{subcommand}'\")\n    if subcommand == \"add\":\n        if not any(r.name.lower() in ['admin', 'mod', 'moderator'] for r in ctx.author.roles):\n            return\n        \n        if not member or not role:\n            return\n        \n        role_lower = role.lower()\n        if role_lower not in ROLE_ORDER:\n            return\n        \n        await db.add_leaderboard_role(member.id, role_lower)\n        await ctx.send(f\"Added {member.mention} to {role_lower} leaderboard!\")\n        return\n    \n    elif subcommand == \"remove\":\n        if not any(r.name.lower() in ['admin', 'mod', 'moderator'] for r in ctx.author.roles):\n            return\n        \n        if not member or not role:\n            return\n        \n        role_lower = role.lower()\n        await db.remove_leaderboard_role(member.id, role_lower)\n        await ctx.send(f\"Removed {member.mention} from {role_lower} leaderboard!\")\n        return\n    \n    elif subcommand == \"w\":\n        await show_leaderboard(ctx, \"weekly\", \"handled\")\n        return\n    \n    elif subcommand == \"c\":\n        await show_leaderboard(ctx, \"all_time\", \"closed\")\n        return\n    \n    elif subcommand == \"cw\":\n        await show_leaderboard(ctx, \"weekly\", \"closed\")\n        return\n    \n    else:\n        await show_leaderboard(ctx, \"all_time\", \"handled\")\n\nasync def show_leaderboard(ctx, timeframe: str, stat_type: str):\n    if not await has_staff_permission(ctx.author, ctx.guild.id):\n        return\n    \n    leaderboard_data = await db.get_leaderboard_data(\n        'weekly' if timeframe == 'weekly' else ('all_time_closed' if stat_type == 'closed' else 'all_time')\n    )\n    \n    user_roles = {}\n    for user_id, all_handled, all_closed, week_handled, week_closed in leaderboard_data:\n        lb_role = await db.get_user_leaderboard_role(user_id)\n        if lb_role:\n            if lb_role not in user_roles:\n                user_roles[lb_role] = []\n            \n            if timeframe == 'weekly':\n                if stat_type == 'closed':\n                    total = week_closed\n                else:\n                    total = week_handled + week_closed\n                weekly_stat = week_closed if stat_type == 'closed' else week_handled + week_closed\n                user_roles[lb_role].append((user_id, all_handled + all_closed if stat_type != 'closed' else all_closed, weekly_stat, total))\n            else:\n                if stat_type == 'closed':\n                    total = all_closed\n                else:\n                    total = all_handled + all_closed\n                weekly_stat = week_closed if stat_type == 'closed' else week_handled + week_closed\n                user_roles[lb_role].append((user_id, total, weekly_stat, total))\n    \n    for role in user_roles:\n        user_roles[role].sort(key=lambda x: x[3], reverse=True)\n    \n    if stat_type == 'closed':\n        title = \"closed leaderboard ð™š â€§â‚ŠËš â‹…\"\n    else:\n        title = \"leaderboard ð™š â€§â‚ŠËš â‹…\"\n    \n    description = \"\"\n    for role in ROLE_ORDER:\n        if role in user_roles and user_roles[role]:\n            emoji = ROLE_EMOJIS.get(role, \"\")\n            description += f\"\\n{emoji} {role}\\n\"\n            \n            for user_id, all_time_stat, weekly_stat, _ in user_roles[role]:\n                description += f\"<@{user_id}> **{all_time_stat}** all - **{weekly_stat}** 7d\\n\"\n    \n    if not description:\n        description = \"No leaderboard data available.\"\n    \n    embed = discord.Embed(\n        title=title,\n        description=description,\n        color=EMBED_COLOR\n    )\n    \n    await ctx.send(embed=embed)\n\n@bot.command()\nasync def modify(ctx, member: discord.Member, stat: str, value: int):\n    if not any(role.name.lower() in ['admin', 'mod', 'moderator'] for role in ctx.author.roles):\n        return\n    \n    valid_stats = ['wclosed', 'whandled', 'closed', 'handled']\n    if stat.lower() not in valid_stats:\n        return\n    \n    stat_map = {\n        'wclosed': 'weekly_closed',\n        'whandled': 'weekly_handled',\n        'closed': 'all_time_closed',\n        'handled': 'all_time_handled'\n    }\n    \n    await db.modify_stats(member.id, stat_map[stat.lower()], value)\n    await ctx.send(f\"Modified {member.mention}'s {stat} by {value}!\")\n\n@tasks.loop(hours=1)\nasync def weekly_reset_task():\n    est = pytz.timezone('US/Eastern')\n    now = datetime.now(est)\n    \n    if now.weekday() == 6 and now.hour == 4:\n        await db.reset_weekly_stats()\n        print(\"Weekly stats reset!\")\n\n@tasks.loop(hours=1)\nasync def sunday_leaderboard():\n    est = pytz.timezone('US/Eastern')\n    now = datetime.now(est)\n    \n    if now.weekday() == 6 and now.hour == 4:\n        for guild in bot.guilds:\n            lb_channel_id = await db.get_leaderboard_channel(guild.id)\n            if lb_channel_id:\n                channel = bot.get_channel(lb_channel_id)\n                if channel:\n                    all_time_data = await build_leaderboard_embed(\"all_time\", \"handled\")\n                    weekly_data = await build_leaderboard_embed(\"weekly\", \"handled\")\n                    \n                    await channel.send(embed=all_time_data)\n                    await channel.send(embed=weekly_data)\n\nasync def build_leaderboard_embed(timeframe: str, stat_type: str):\n    leaderboard_data = await db.get_leaderboard_data(\n        'weekly' if timeframe == 'weekly' else 'all_time'\n    )\n    \n    user_roles = {}\n    for user_id, all_handled, all_closed, week_handled, week_closed in leaderboard_data:\n        lb_role = await db.get_user_leaderboard_role(user_id)\n        if lb_role:\n            if lb_role not in user_roles:\n                user_roles[lb_role] = []\n            \n            if timeframe == 'weekly':\n                total = week_handled + week_closed\n                user_roles[lb_role].append((user_id, all_handled + all_closed, week_handled + week_closed, total))\n            else:\n                total = all_handled + all_closed\n                user_roles[lb_role].append((user_id, total, week_handled + week_closed, total))\n    \n    for role in user_roles:\n        user_roles[role].sort(key=lambda x: x[3], reverse=True)\n    \n    title = \"ð‹ð„ð€ðƒð„ð‘ððŽð€ð‘ðƒ ð™š â€§â‚ŠËš â‹…\" if timeframe == \"all_time\" else \"ð–ð„ð„ðŠð‹ð˜ ð‹ð„ð€ðƒð„ð‘ððŽð€ð‘ðƒ ð™š â€§â‚ŠËš â‹…\"\n    \n    description = \"\"\n    for role in ROLE_ORDER:\n        if role in user_roles and user_roles[role]:\n            emoji = ROLE_EMOJIS.get(role, \"\")\n            description += f\"\\n{emoji} {role}\\n\"\n            \n            for user_id, all_time_stat, weekly_stat, _ in user_roles[role]:\n                description += f\"<@{user_id}> **{all_time_stat}** all - **{weekly_stat}** 7d\\n\"\n    \n    if not description:\n        description = \"No leaderboard data available.\"\n    \n    embed = discord.Embed(\n        title=title,\n        description=description,\n        color=EMBED_COLOR\n    )\n    \n    return embed\n\nbot.run(os.getenv('DISCORD_TOKEN'))","size_bytes":26499},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/IMPLEMENTATION.md":{"content":"# Implementation Summary\n\n## Completed Features\n\n### 1. Ticket System âœ“\n- **Category Dropdown**: Implemented in `TicketCategorySelect` class with 5 options (middleman, pilot, verify, giveaway, other)\n- **Automatic Numbering**: Database auto-increment for ticket numbers\n- **Ticket Limits**: `.ticketlimit` command sets max open tickets\n- **Ephemeral Full Message**: When limit reached, shows \"Tickets are currently full. try again later!\" with `ephemeral=True`\n- **Persistent Ticket Message**: `.sendticket` command (owner only) creates persistent dropdown\n\n### 2. Ticket Management âœ“\n- **Claim System**: `.claim` and `.claim force` (admin only)\n- **Unclaim System**: `.unclaim` and `.unclaim force` (admin only)\n- **Credits**: Automatic credit attribution on claim/unclaim\n- **Close with Transcript**: `.close <reason>` with confirmation prompt\n- **Archive Posting**: Full transcript embed posted to archive channel\n- **DM to Opener**: Transcript sent via DM with button link\n- **Transcript Details**: Includes opener, handler, closer, timestamps, duration, close reason\n- **Embed Color**: f9e6f0 throughout\n\n### 3. Staff Commands âœ“\n- `.fm` - Jump to first message with embed and hyperlink\n- `.add @user` - Add user to thread\n- `.remove @user` - Remove user from thread  \n- `.rename <name>` - Rename thread\n- `.profile edit <message>` - Set custom profile message\n- `.stats [@user]` - View stats with profile image\n\n### 4. Stats & Image Generation âœ“\n- **885x303 Image**: Created in `image_utils.py`\n- **Banner Display**: Shows Discord banner (blurred) if available\n- **Fallback**: Uses blurred avatar if no banner\n- **Circular Avatar**: Left-positioned circular avatar\n- **Stats Display**: All-time and weekly handled/closed counts\n- **Profile Message**: Custom message shown in stats\n- **Role Assignment Date**: Tracked and displayed\n\n### 5. Leaderboard System âœ“\n- **Custom Formatting**: Exact format as specified\n  - Title: `*##leaderboard* ð™š â€§â‚ŠËš â‹…` for .lb/.lb w\n  - Title: `*##closed leaderboard* ð™š â€§â‚ŠËš â‹…` for .lb c/.lb cw\n- **Role Emojis**: \n  - owner: `<a:white_butterflies:1390909884928884886>`\n  - co-owner: `<:piano_smile:1396035361091752080>`\n  - admin: `<:miffy_plush:1390909592543957063>`\n  - staff: `<a:cutebunny:1390853287347228914>`\n  - trial: `<a:pink_bubbles:1396386164637958294>`\n- **Hide Empty Sections**: Only shows roles with members\n- **Sorting**: Descending by stats within each role\n- **Format**: `@username **XXX** all - **YY** 7d`\n\n### 6. Leaderboard Commands âœ“\n- `.lb` - All-time handles leaderboard\n- `.lb w` - Weekly handles leaderboard (sorted by weekly handles)\n- `.lb c` - All-time closes leaderboard  \n- `.lb cw` - Weekly closes leaderboard (sorted by weekly closes)\n- `.lb add @user <role>` - Add user to leaderboard role\n- `.lb remove @user <role>` - Remove user from leaderboard role\n\n### 7. Admin Commands âœ“\n- `.modify @user <stat> <value>` - Modify stats\n  - Valid stats: wclosed, whandled, closed, handled\n  - Admin/Mod only\n\n### 8. Automated Tasks âœ“\n- **Weekly Reset**: Sunday 4 AM EST via `weekly_reset_task`\n- **Leaderboard Posts**: Sunday 4 AM EST via `sunday_leaderboard`\n- **Timezone**: pytz with US/Eastern timezone\n\n### 9. Database âœ“\n- **SQLite**: Persistent storage in `bot_data.db`\n- **Tables**:\n  - tickets (ticket_number, channel_id, category, opener_id, handler_id, closer_id, timestamps, status)\n  - user_stats (all-time and weekly handled/closed, profile_message, role_assignment_date)\n  - leaderboard_roles (user to role mapping)\n  - server_config (ticket_limit, archive_channel, ticket_message, leaderboard_channel)\n  - weekly_reset (last reset timestamp)\n\n### 10. Setup Commands âœ“\n- `.sendticket` - Owner only\n- `.ticketlimit <number>` - Owner only\n- `.setarchive #channel` - Owner only\n- `.setleaderboard #channel` - Owner only\n\n## File Structure\n\n```\nbot.py              # Main bot logic with all commands\ndatabase.py         # Database operations and schema\nimage_utils.py      # Stats image generation (885x303)\nREADME.md           # User documentation\nIMPLEMENTATION.md   # This file\n.gitignore          # Python/Replit ignore patterns\n```\n\n## Permission Levels\n\n1. **Owner**: sendticket, ticketlimit, setarchive, setleaderboard\n2. **Admin/Mod**: close, claim force, unclaim force, modify, lb add/remove\n3. **Staff**: claim, unclaim, fm, add, remove, rename, profile edit, stats, lb (view)\n\n## Bot Status\n\nâœ… Bot is running and connected to Discord\nâœ… All features implemented as specified\nâœ… Database initialized and ready\nâœ… Scheduled tasks configured\n","size_bytes":4561},"WorthwhileRobustSeptagon/WorthwhileRobustSeptagon/replit.md":{"content":"# Overview\n\nThis is a Discord ticket management and staff statistics bot built with discord.py. The bot provides a comprehensive ticket system with category-based creation, claim/unclaim functionality, transcript archiving, and automated staff performance tracking. It features a hierarchical leaderboard system that resets weekly and displays staff statistics with custom profile images.\n\n**Status**: âœ… Bot is fully implemented and running as \"kirei#2389\"\n\n# Recent Changes\n\n**October 19, 2025** (Latest Update - Bug Fixes & UI Improvements v2)\n- Fixed \"interaction failed\" error for ticket creation by adding persistent view registration with custom_id\n- Sized up leaderboard titles significantly using Unicode bold characters (ð‹ð„ð€ðƒð„ð‘ððŽð€ð‘ðƒ)\n- Added debug logging to diagnose potential double message issue in .rename, .stats, and .lb commands\n- Configured Reserved VM deployment for always-on bot operation\n- Fixed .stats command to no longer delete user's command message\n- Fixed double messages bug in .stats and .lb commands by removing redundant bot.fetch_user() calls\n- Made leaderboard names clickable by using <@{user_id}> format instead of @{user.name}\n- Updated ticket close confirmation embed: \"Ticket Confirmation\" title with \"Credit given:\" field\n- Updated ticket close final embed: \"ticket closed <a:Heart:1396388971818520576>\" title with proper formatting\n- Verified bot runs successfully as \"kirei#2389\"\n\n**October 17, 2025** (Previous Update - Bug Fixes & Improvements)\n- Fixed .stats command to ensure only one message is sent (now deletes command message after sending stats)\n- Updated leaderboard role labels to: owner, co-owner, head admin, admin, staff, trial staff\n- Enhanced close command confirmation:\n  - Shows \"Ticket Confirmation\" as title with \"are you sure you want to close?\" subtitle\n  - Displays \"Credit given: (handler)\" field showing who will receive credit\n- Added final closing embed:\n  - Title: \"ticket closed <a:Heart:1396388971818520576>\"\n  - Shows closer mention and reason in description\n- Fixed all type errors and LSP diagnostics:\n  - Changed None default parameters to empty strings for type safety\n  - Added null checks for ticket_info retrieval\n  - Added is_running() checks before starting background tasks\n- Verified bot runs successfully as \"kirei#2389\"\n\n**October 17, 2025** (Previous Update - Major Improvements)\n- Changed max tickets message to \"TAIYO is currently at max tickets. Please try again later.\"\n- Enhanced stats system:\n  - Increased profile picture size from 200x200 to 250x250\n  - Increased username font size from 48px to 60px for better visibility\n  - Relocated staff join date to bottom right corner with rounded background\n  - Join date now displays as Discord timestamp showing when user received role 1407881544202195004\n  - Rank now shows highest staff role from hierarchical role list (Owner â†’ Co-Owner â†’ Head Admin â†’ Admin â†’ Mod â†’ Trial Mod â†’ Lead MM â†’ MM â†’ Trial MM â†’ Pilot â†’ Trial Pilot)\n- Improved transcript system:\n  - Changed transcript file format from .txt to .html with Discord-themed styling\n  - Simplified transcript filename to \"ticket #X.html\"\n  - Reformatted transcript embed to show opened by/closed by/handled by on one line\n  - Added Discord timestamps for opened at/closed at times\n- Updated leaderboard:\n  - Changed all leaderboard titles to lowercase (\"leaderboard\", \"closed leaderboard\", \"weekly leaderboard\")\n  - .lb add command remains admin-only\n- Added .setroles command for configurable role-based permissions (admin, owner, moderator, staff)\n- Fixed .setstaffroles database initialization with proper column migration\n- Added new database columns for role type management (admin_role_ids, owner_role_ids, moderator_role_ids)\n- Verified bot runs successfully as \"kirei#2389\"\n\n**Previous Updates**\n- Added .setstaffroles command for configurable staff permissions\n- Updated all commands to use silent permission checks (no error messages)\n- Redesigned stats embed with new 3x2 layout (Rank/Closed/Handled stats)\n- Updated ticket creation to ping role and show type as heading\n- Made .rename command silent (no confirmation)\n- Updated .claim to send embed reply and delete original message\n- Changed leaderboard formatting to bold text headings\n- Implemented complete ticket system with 5 categories (middleman, pilot, verify, giveaway, other)\n- Created stats image generation (885x303px) with Discord banner/avatar support\n- Implemented automated Sunday 4 AM EST weekly reset and leaderboard posting\n- Set up database schema with SQLite for persistent storage\n- Added admin commands (.modify, .lb add/remove, .claim force, .unclaim force)\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework\n- **discord.py**: Core Discord bot framework with commands extension and app_commands for slash commands\n- **Command Prefix**: Dot (`.`) prefix for text-based commands\n- **Intents**: Requires message_content, members, and guilds intents for full functionality\n\n## Database Design\n- **SQLite with aiosqlite**: Async database operations for non-blocking I/O\n- **Schema Structure**:\n  - `tickets`: Tracks ticket lifecycle with auto-incrementing ticket numbers, channel associations, handler/closer assignments, and status tracking\n  - `user_stats`: Stores all-time and weekly statistics (handled/closed counts), custom profile messages, and role assignment dates\n  - `leaderboard_roles`: Many-to-many relationship for user-role assignments in leaderboard hierarchy\n  - `server_config`: Guild-specific settings including ticket limits, archive channels, leaderboard channels, and role type configurations (staff_role_ids, admin_role_ids, owner_role_ids, moderator_role_ids)\n\n## Ticket System Architecture\n- **Persistent UI Components**: Dropdown select menu (TicketCategorySelect) for ticket creation with 5 categories (middleman, pilot, verify, giveaway, other)\n- **Ticket Lifecycle**:\n  1. Creation via category selection\n  2. Optional claim by staff (with force claim for admins)\n  3. Closure with reason and confirmation\n  4. Transcript generation and archiving\n  5. DM notification to ticket opener\n- **Limit Enforcement**: Configurable maximum open tickets with ephemeral message \"Max tickets are currently opened, try again later.\" when full\n- **Credit System**: Automatic credit attribution on claim/unclaim actions\n\n## Statistics & Leaderboard System\n- **Dual Tracking**: Separate all-time and weekly statistics for both handled and closed tickets\n- **Role Hierarchy**: Five-tier system (owner â†’ co-owner â†’ admin â†’ staff â†’ trial) with custom emojis per role\n- **Weekly Reset**: Automated Sunday 4 AM EST reset of weekly statistics using discord.py tasks\n- **Leaderboard Formatting**: \n  - Custom titles with decorative Unicode characters\n  - Role-based sections (hidden if empty)\n  - Descending sort within each role tier\n  - Support for both handles and closes leaderboards\n\n## Image Generation\n- **Stats Profile Cards**: 885x303px images generated with PIL (Pillow)\n- **Background Logic**:\n  - Primary: Blurred Discord banner if available\n  - Fallback: Blurred avatar image\n- **Avatar Overlay**: Circular masked avatar (250x250) positioned on left side\n- **Username Display**: Centered, 60px bold font, positioned at y=120 for optimal visibility\n- **Join Date Badge**: Discord timestamp of staff role assignment displayed in bottom-right with rounded rectangle background\n- **Async Image Fetching**: Uses aiohttp for non-blocking image downloads\n\n## Permission Structure\n- **Owner-only**: `.sendticket`, `.ticketlimit`, `.setstaffroles`, `.setroles`, server configuration commands\n- **Admin/Mod**: `.claim force`, `.unclaim force`, `.modify`, `.close`\n- **Staff**: `.claim`, `.unclaim`, `.add`, `.remove`, `.rename`, `.profile edit`, `.stats`, `.lb` commands\n- **Role-based Access**: Leaderboard management (`.lb add`/`.lb remove`) restricted to admins\n- **Configurable Roles**: Use `.setroles <type> @role1 @role2...` to set admin, owner, moderator, or staff roles\n\n## Transcript System\n- **Archive Channel**: Dedicated channel for permanent transcript storage\n- **File Format**: HTML files with Discord-themed styling (dark mode colors, message cards)\n- **Filename**: Simplified to \"ticket #X.html\" format\n- **Embed Format**: f9e6f0 color with compact layout showing opened by/closed by/handled by on one line, Discord timestamps for dates, and close reason\n- **Dual Delivery**: Posted to archive channel and DM'd to ticket opener with button link back to thread\n- **Confirmation Prompts**: Two-step confirmation process for ticket closure\n\n## Task Automation\n- **Weekly Reset**: discord.py tasks loop for Sunday 4 AM EST execution\n- **Auto-posting**: Leaderboards automatically posted to configured channel on weekly reset\n- **Timezone Handling**: pytz for EST/EDT timezone conversions\n\n# External Dependencies\n\n## Discord API\n- **discord.py**: Main bot framework with commands, app_commands, and UI components\n- **Required Intents**: message_content, members, guilds\n\n## Database\n- **SQLite**: Local file-based database (`bot_data.db`)\n- **aiosqlite**: Async SQLite driver for non-blocking database operations\n\n## Image Processing\n- **Pillow (PIL)**: Image generation, manipulation, blurring effects, and circular masking\n- **aiohttp**: Async HTTP client for fetching Discord avatars and banners\n\n## Utilities\n- **python-dotenv**: Environment variable management for bot token\n- **pytz**: Timezone handling for EST scheduling\n- **datetime**: Timestamp tracking and duration calculations\n\n## Discord Assets\n- **Custom Emojis**: Five role-specific animated/static emojis (IDs hardcoded in ROLE_EMOJIS dict)\n- **Embed Color**: Consistent f9e6f0 hex color throughout all embeds\n\n## Configuration\n- **Environment Variables**: Bot token stored in `.env` file\n- **Guild-specific Settings**: Archive channels, leaderboard channels, and ticket limits stored per-guild in database","size_bytes":10004}},"version":2}